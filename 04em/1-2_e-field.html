<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HKDSE 物理模擬：統一電場 (手機觸控版)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* 防止整體捲動 */
            touch-action: none; /* 禁止瀏覽器預設觸控行為 */
        }
        
        #controls {
            background: white;
            padding: 10px 15px;
            border-bottom: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            width: 100%;
            z-index: 20;
            box-sizing: border-box;
            max-height: 30vh; /* 確保控制面板不佔滿手機螢幕 */
            overflow-y: auto;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: #f9f9f9;
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .control-group h4 {
            margin: 0 0 3px 0;
            font-size: 0.85rem;
            color: #555;
        }

        label {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        select, input[type=range] { margin-top: 2px; }

        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            height: 70vh; /* 確保畫布有足夠空間 */
            background-color: #fff;
            cursor: default;
            touch-action: none; /* 關鍵：禁止畫布上的捲動手勢 */
        }

        canvas { display: block; width: 100%; height: 100%; }

        #legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.75rem;
            border: 1px solid #ccc;
            pointer-events: none;
            user-select: none;
            z-index: 15;
        }
    </style>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <h4>物體 1 (Q1)</h4>
            <label>電荷: <span id="valQ1" style="width:30px; text-align:right;">+2</span> μC</label>
            <input type="range" id="sliderQ1" min="-5" max="5" step="1" value="2">
        </div>

        <div class="control-group">
            <h4>物體 2 (Q2)</h4>
            <select id="selectObj2">
                <option value="none">無 (None)</option>
                <option value="point" selected>點電荷 (Point)</option>
                <option value="plate">帶電板 (Plate)</option>
            </select>
            <div id="controlsObj2" style="margin-top:5px; width: 100%;">
                <label>電荷: <span id="valQ2" style="width:30px; text-align:right;">-2</span></label>
                <input type="range" id="sliderQ2" min="-5" max="5" step="1" value="-2">
            </div>
        </div>

        <div class="control-group">
            <h4>設定</h4>
            <label><input type="checkbox" id="chkGrid" checked> 網格</label>
            <label>密度: <input type="range" id="sliderDensity" min="4" max="12" step="1" value="8"></label>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
        <div id="legend">
            <strong>圖例</strong><br>
            <span style="color:#ff4444; font-weight:bold;">●</span> 正電荷 (+)<br>
            <span style="color:#4444ff; font-weight:bold;">●</span> 負電荷 (-)<br>
            <span style="color:#666;">→</span> 電場方向
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        // UI Ref
        const sliderQ1 = document.getElementById('sliderQ1');
        const valQ1 = document.getElementById('valQ1');
        const selectObj2 = document.getElementById('selectObj2');
        const controlsObj2 = document.getElementById('controlsObj2');
        const sliderQ2 = document.getElementById('sliderQ2');
        const valQ2 = document.getElementById('valQ2');
        const sliderDensity = document.getElementById('sliderDensity');
        const chkGrid = document.getElementById('chkGrid');

        let width, height;
        
        // State
        const state = {
            objects: [], 
            linesPerQ: 8,
            stepSize: 8,
            maxSteps: 600
        };

        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

        function init() {
            resize();
            // Init objects
            state.objects = [{ 
                type: 'point', 
                x: width * 0.3, 
                y: height * 0.5, 
                q: parseFloat(sliderQ1.value), 
                radius: 20 // 稍微加大半徑方便手機點擊
            }];
            setupObj2(); 
            loop();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            if (!width) width = window.innerWidth;
            if (!height) height = window.innerHeight * 0.7;
            canvas.width = width;
            canvas.height = height;
            validatePositions();
        }

        function validatePositions() {
            if (!state.objects) return;
            state.objects.forEach(obj => {
                const margins = getObjectMargins(obj);
                if (isNaN(obj.x)) obj.x = width * 0.5;
                if (isNaN(obj.y)) obj.y = height * 0.5;
                obj.x = clamp(obj.x, margins.xMin, margins.xMax);
                obj.y = clamp(obj.y, margins.yMin, margins.yMax);
            });
        }

        function getObjectMargins(obj) {
            const padding = 20;
            if (obj.type === 'plate') {
                const halfLen = (obj.length || 200) / 2;
                return {
                    xMin: padding + 10,
                    xMax: width - padding - 10,
                    yMin: halfLen + padding, 
                    yMax: height - halfLen - padding
                };
            } else {
                const r = obj.radius || 20;
                return {
                    xMin: r + padding,
                    xMax: width - r - padding,
                    yMin: r + padding,
                    yMax: height - r - padding
                };
            }
        }

        function setupObj2() {
            const type = selectObj2.value;
            if (state.objects.length === 0) return;
            
            const q1 = state.objects[0];
            state.objects = [q1];
            
            if (type !== 'none') {
                controlsObj2.style.display = 'block';
                let newObj = {
                    type: type,
                    x: width * 0.7,
                    y: height * 0.5,
                    q: parseFloat(sliderQ2.value),
                };
                if (isNaN(newObj.x)) newObj.x = width * 0.7;
                if (isNaN(newObj.y)) newObj.y = height * 0.5;

                if (type === 'plate') newObj.length = 200;
                else newObj.radius = 20;
                
                state.objects.push(newObj);
                validatePositions();
            } else {
                controlsObj2.style.display = 'none';
            }
        }

        // Event Listeners
        selectObj2.addEventListener('change', () => { setupObj2(); updateFromUI(); });
        [sliderQ1, sliderQ2, sliderDensity].forEach(el => el.addEventListener('input', updateFromUI));

        function updateFromUI() {
            if (!state.objects[0]) return;
            state.objects[0].q = parseFloat(sliderQ1.value);
            valQ1.textContent = (state.objects[0].q > 0 ? "+" : "") + state.objects[0].q;

            if (state.objects.length > 1) {
                state.objects[1].q = parseFloat(sliderQ2.value);
                valQ2.textContent = (state.objects[1].q > 0 ? "+" : "") + state.objects[1].q;
            }
            state.linesPerQ = parseInt(sliderDensity.value);
        }

        // --- Physics Engine ---
        function getElectricField(x, y) {
            let Ex = 0, Ey = 0;
            const k = 5000; 

            state.objects.forEach(obj => {
                if (Math.abs(obj.q) < 0.1) return;
                if (obj.type === 'point') {
                    const dx = x - obj.x;
                    const dy = y - obj.y;
                    const r2 = dx*dx + dy*dy;
                    const r = Math.sqrt(r2);
                    if (r < 5) return;
                    const E = k * obj.q / r2;
                    Ex += E * (dx / r);
                    Ey += E * (dy / r);
                } 
                else if (obj.type === 'plate') {
                    const numSegments = 25;
                    const dq = obj.q / numSegments;
                    const halfLen = obj.length / 2;
                    for(let i=0; i<numSegments; i++) {
                        const py = obj.y - halfLen + (i * obj.length/numSegments) + (obj.length/numSegments/2);
                        const dx = x - obj.x;
                        const dy = y - py;
                        const r2 = dx*dx + dy*dy;
                        const r = Math.sqrt(r2);
                        if (r < 5) continue;
                        const E = (k/3.5) * dq / r2; 
                        Ex += E * (dx / r);
                        Ey += E * (dy / r);
                    }
                }
            });
            return { Ex, Ey };
        }

        // --- Unified Interaction Handler (Mouse & Touch) ---
        let draggedObj = null;

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            // 檢查是否為觸控事件
            if (e.touches && e.touches.length > 0) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            } else {
                // 滑鼠事件
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
        }

        function handleStart(e) {
            const pos = getPointerPos(e);
            
            for (let obj of state.objects) {
                let hit = false;
                // 加大手機版的點擊判定範圍 (+10px)
                const hitBuffer = 10; 
                
                if (obj.type === 'point') {
                    if (Math.hypot(pos.x-obj.x, pos.y-obj.y) < (obj.radius || 20) + hitBuffer) hit = true;
                } else if (obj.type === 'plate') {
                    if (Math.abs(pos.x-obj.x) < 25 + hitBuffer && Math.abs(pos.y-obj.y) < obj.length/2) hit = true;
                }

                if (hit) {
                    draggedObj = obj;
                    canvas.style.cursor = 'grabbing';
                    // 重要：防止手機上拖曳時畫面捲動
                    if(e.cancelable) e.preventDefault(); 
                    break;
                }
            }
        }

        function handleMove(e) {
            const pos = getPointerPos(e);

            if (draggedObj) {
                // 防止拖曳時捲動頁面
                if(e.cancelable) e.preventDefault();
                
                const margins = getObjectMargins(draggedObj);
                draggedObj.x = clamp(pos.x, margins.xMin, margins.xMax);
                draggedObj.y = clamp(pos.y, margins.yMin, margins.yMax);
            } else {
                // Hover Check
                let hover = false;
                state.objects.forEach(obj => {
                     if (obj.type==='point' && Math.hypot(pos.x-obj.x, pos.y-obj.y)<30) hover=true;
                     if (obj.type==='plate' && Math.abs(pos.x-obj.x)<20 && Math.abs(pos.y-obj.y)<obj.length/2) hover=true;
                });
                canvas.style.cursor = hover ? 'grab' : 'default';
            }
        }

        function handleEnd(e) {
            if (draggedObj) {
                draggedObj = null;
                canvas.style.cursor = 'default';
            }
        }

        // Mouse Events
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        // Touch Events (Passive: false 是為了能使用 preventDefault)
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('touchend', handleEnd);


        // --- Rendering Loop ---
        function loop() {
            ctx.clearRect(0, 0, width, height);
            if (chkGrid.checked) drawGrid();
            try { drawUnifiedField(); } catch(e) {}
            drawObjects();
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);

        function drawGrid() {
            ctx.strokeStyle = '#f5f5f5';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<width; x+=40) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
            for(let y=0; y<height; y+=40) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
            ctx.stroke();
        }

        function drawObjects() {
            state.objects.forEach((obj, index) => {
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#333';
                if (obj.type === 'point') {
                    const grad = ctx.createRadialGradient(obj.x, obj.y, obj.radius*0.2, obj.x, obj.y, obj.radius);
                    const color = obj.q > 0 ? '#ff4444' : (obj.q < 0 ? '#4444ff' : '#999');
                    grad.addColorStop(0, color);
                    grad.addColorStop(1, color); 
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI*2);
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(obj.q > 0 ? "+" : (obj.q < 0 ? "-" : ""), obj.x, obj.y);
                    ctx.fillStyle = '#444';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(index === 0 ? "Q1" : "Q2", obj.x, obj.y - obj.radius - 8);
                } else if (obj.type === 'plate') {
                    const half = obj.length/2;
                    ctx.beginPath();
                    ctx.rect(obj.x - 6, obj.y - half, 12, obj.length);
                    ctx.fillStyle = obj.q > 0 ? '#ff8888' : (obj.q < 0 ? '#8888ff' : '#ccc');
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    for(let i=-0.8; i<=0.8; i+=0.3) {
                        ctx.fillText(obj.q > 0 ? "+" : "-", obj.x, obj.y + i*half);
                    }
                }
            });
        }

        function drawArrow(x, y, angle, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(-5, -4);
            ctx.lineTo(6, 0); 
            ctx.lineTo(-5, 4);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }

        function drawUnifiedField() {
            state.objects.forEach(obj => {
                if (Math.abs(obj.q) < 0.1) return;
                const numLines = Math.floor(Math.abs(obj.q) * state.linesPerQ);
                let isEmitter = obj.q > 0;
                let isCollector = obj.q < 0;

                for (let i = 0; i < numLines; i++) {
                    let startX, startY;
                    if (obj.type === 'point') {
                        const angle = (Math.PI * 2 * i) / numLines;
                        const dist = (obj.radius || 20) + 2;
                        startX = obj.x + Math.cos(angle) * dist;
                        startY = obj.y + Math.sin(angle) * dist;
                    } else if (obj.type === 'plate') {
                        const side = (i % 2 === 0) ? 1 : -1; 
                        const segmentIndex = Math.floor(i / 2);
                        const totalPairs = Math.ceil(numLines / 2);
                        const ratio = (segmentIndex + 0.5) / totalPairs;
                        const posAlongPlate = (ratio - 0.5) * obj.length * 0.9;
                        startX = obj.x + side * 12; 
                        startY = obj.y + posAlongPlate;
                    }
                    if (isEmitter) traceLine(startX, startY, 1, obj.q, false);
                    else if (isCollector) traceLine(startX, startY, -1, obj.q, true);
                }
            });
        }

        function traceLine(x, y, sign, sourceQ, checkForPositiveCollision) {
            let points = [{x, y}];
            let currX = x, currY = y;
            let hitPositive = false; 

            for (let step = 0; step < state.maxSteps; step++) {
                const f = getElectricField(currX, currY);
                const E = Math.sqrt(f.Ex**2 + f.Ey**2);
                if (E < 0.001) break;

                const dx = (f.Ex / E) * state.stepSize * sign;
                const dy = (f.Ey / E) * state.stepSize * sign;
                const nextX = currX + dx;
                const nextY = currY + dy;

                if (nextX < 0 || nextX > width || nextY < 0 || nextY > height) break;

                let hitAny = false;
                for(let obj of state.objects) {
                    let isHit = false;
                    if (obj.type==='point' && Math.hypot(nextX-obj.x, nextY-obj.y) < (obj.radius || 20)) isHit = true;
                    if (obj.type==='plate' && Math.abs(nextX-obj.x)<10 && Math.abs(nextY-obj.y)<obj.length/2) isHit = true;
                    if (isHit) {
                        hitAny = true;
                        if (checkForPositiveCollision && obj.q > 0) hitPositive = true;
                    }
                }
                points.push({x: nextX, y: nextY, e: E});
                if (hitAny) break; 
                currX = nextX;
                currY = nextY;
            }

            if (checkForPositiveCollision && hitPositive) return; 

            if (points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                const grad = ctx.createLinearGradient(points[0].x, points[0].y, points[points.length-1].x, points[points.length-1].y);
                grad.addColorStop(0, "rgba(80,80,80,0.6)");
                grad.addColorStop(1, "rgba(80,80,80,0.1)");
                ctx.strokeStyle = grad;
                ctx.stroke();

                if (points.length > 8) {
                    const idx = Math.floor(points.length / 2);
                    const p1 = points[idx], p2 = points[idx+1];
                    if (p2) {
                        const ang = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                        const arrowColor = sourceQ > 0 ? '#ff4444' : '#4444ff';
                        drawArrow(p1.x, p1.y, ang + (sign===-1 ? Math.PI : 0), arrowColor);
                    }
                }
            }
        }
        
        init();
    </script>
</body>
</html>